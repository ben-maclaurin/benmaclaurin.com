<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Fast motions with avy and evil -</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Ben MacLaurin"><meta name=description content="Table of Contents How it works Watch the video I have discovered a beautifully versatile motion technique via avy with evil mode. Both packages are admirable in their own right. avy brings char-based decision tree jumping to the buffer, and evil is an extensible vi layer for Emacs. Combining them, however, feels magic.
How it works Below is some elisp from my init file:
1 (global-set-key (kbd &amp;#34;C-x .&amp;#34;) (lambda () (interactive) (dired &amp;#34;~/."><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.107.0 with theme even"><link rel=canonical href=https://benmaclaurin.com/post/fast-motions-with-avy-and-evil/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.92572562d0ed040cd5ebfeb60de8624bde43d3ec333240ceb7d47cf12fb5d5d0.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Fast motions with avy and evil"><meta property="og:description" content="Table of Contents How it works Watch the video I have discovered a beautifully versatile motion technique via avy with evil mode. Both packages are admirable in their own right. avy brings char-based decision tree jumping to the buffer, and evil is an extensible vi layer for Emacs. Combining them, however, feels magic.
How it works Below is some elisp from my init file:
1 (global-set-key (kbd &#34;C-x .&#34;) (lambda () (interactive) (dired &#34;~/."><meta property="og:type" content="article"><meta property="og:url" content="https://benmaclaurin.com/post/fast-motions-with-avy-and-evil/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-30T00:49:00+01:00"><meta property="article:modified_time" content="2022-10-30T00:49:00+01:00"><meta itemprop=name content="Fast motions with avy and evil"><meta itemprop=description content="Table of Contents How it works Watch the video I have discovered a beautifully versatile motion technique via avy with evil mode. Both packages are admirable in their own right. avy brings char-based decision tree jumping to the buffer, and evil is an extensible vi layer for Emacs. Combining them, however, feels magic.
How it works Below is some elisp from my init file:
1 (global-set-key (kbd &#34;C-x .&#34;) (lambda () (interactive) (dired &#34;~/."><meta itemprop=datePublished content="2022-10-30T00:49:00+01:00"><meta itemprop=dateModified content="2022-10-30T00:49:00+01:00"><meta itemprop=wordCount content="298"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Fast motions with avy and evil"><meta name=twitter:description content="Table of Contents How it works Watch the video I have discovered a beautifully versatile motion technique via avy with evil mode. Both packages are admirable in their own right. avy brings char-based decision tree jumping to the buffer, and evil is an extensible vi layer for Emacs. Combining them, however, feels magic.
How it works Below is some elisp from my init file:
1 (global-set-key (kbd &#34;C-x .&#34;) (lambda () (interactive) (dired &#34;~/."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo></a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/about/><li class=mobile-menu-item>About</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo></a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Fast motions with avy and evil</h1><div class=post-meta><span class=post-time>2022-10-30</span></div></header><div class=post-content><div class="ox-hugo-toc toc"><div class=heading>Table of Contents</div><ul><li><a href=#how-it-works>How it works</a></li><li><a href=#watch-the-video>Watch the video</a></li></ul></div><p>I have discovered a beautifully versatile motion technique via avy
with evil mode. Both packages are admirable in their own right. avy
brings <a href=https://github.com/abo-abo/avy>char-based decision tree jumping</a> to the buffer, and evil is <a href=https://github.com/emacs-evil/evil>an
extensible vi layer</a> for Emacs. Combining them, however, feels <em>magic</em>.</p><h2 id=how-it-works>How it works</h2><p>Below is some elisp from my init file:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=p>(</span><span class=nv>global-set-key</span> <span class=p>(</span><span class=nv>kbd</span> <span class=s>&#34;C-x .&#34;</span><span class=p>)</span> <span class=p>(</span><span class=nb>lambda</span> <span class=p>()</span> <span class=p>(</span><span class=nv>interactive</span><span class=p>)</span> <span class=p>(</span><span class=nv>dired</span> <span class=s>&#34;~/.emacs.d/&#34;</span><span class=p>)))</span>
</span></span></code></pre></td></tr></table></div></div><p>What if I want to delete from the beginning of the line to the end of
<code>(interactive)</code>?</p><p>Maybe <code>df)</code>? No. That would give me:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=p>(</span><span class=nb>lambda</span> <span class=p>()</span> <span class=p>(</span><span class=nv>interactive</span><span class=p>)</span> <span class=p>(</span><span class=nv>dired</span> <span class=s>&#34;~/.emacs.d/&#34;</span><span class=p>)))</span>
</span></span></code></pre></td></tr></table></div></div><p>Instead, I could count the occurences of <code>)</code> up until the termination
point (there are 3 in this case). <code>d3f)</code> would give me want I want:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=p>(</span><span class=nv>dired</span> <span class=s>&#34;~/.emacs.d/&#34;</span><span class=p>)))</span>
</span></span></code></pre></td></tr></table></div></div><p>With avy, this becomes delightfully simple. We no longer need to count
the occurences of a character. Instead, the following key combination
will work:</p><ol><li><code>d</code> for delete</li><li><code>C-;</code> which is my custom keybinding for <code>avy-goto-char</code></li><li><code>&lt;char></code> where <code>&lt;char></code> is the target char</li><li><code>&lt;avy char></code> which is the character in the visual decision tree
which represents our target</li></ol><p>Here is a screenshot of step 3:</p><figure><img src=/ox-hugo/avy-demo.png></figure><p>In the example screenshot I would press <code>d</code> as this is the character
that corresponds to the termination point.</p><p>So, in <em>approximately</em> the same number of actions we achieved
comparable behaviour without the additional cognitive load of having
to count character occurences.</p><p>Before I switched to Emacs, I tried to set this up with <a href=https://github.com/ggandor/leap.nvim>leap</a> in Neovim
but couldn&rsquo;t get it to work properly.</p><h2 id=watch-the-video>Watch the video</h2><iframe width=100% height=315 src=https://www.youtube.com/embed/FiLgoZgaqYo title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><blockquote><p><em>There is a good chance parts of this post are incorrect. I&rsquo;m always keen to update my ideas, so if you disagree with anything, I&rsquo;d be grateful if you could <a href=mailto:contact@benmaclaurin.com>reach out via email</a>.</em></p></blockquote></div><footer class=post-footer><nav class=post-nav><a class=next href=/post/improving-vim-form/><span class="next-text nav-default">Improving Vim Form</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=https://benmaclaurin.com/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=copyright-year>©2022<span> Ben MacLaurin</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>