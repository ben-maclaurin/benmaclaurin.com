<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://benmaclaurin.com/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 30 Oct 2022 00:49:00 +0100</lastBuildDate><atom:link href="https://benmaclaurin.com/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>https://benmaclaurin.com/about/</link><pubDate>Sat, 19 Nov 2022 13:20:00 +0000</pubDate><guid>https://benmaclaurin.com/about/</guid><description>About Hello. I&amp;rsquo;m a UI designer and developer based in Edinburgh. I currently work at Mawla. I spend most of my time in TypeScript, Elixir and Rust. I occasionally write some Emacs Lisp, too!
You can find me on:
GitHub Spotify Are.na sourcehut You can also reach me on: contact@benmaclaurin.com</description></item><item><title>Fast motions with avy and evil</title><link>https://benmaclaurin.com/post/fast-motions-with-avy-and-evil/</link><pubDate>Sun, 30 Oct 2022 00:49:00 +0100</pubDate><guid>https://benmaclaurin.com/post/fast-motions-with-avy-and-evil/</guid><description>Table of Contents How it works Watch the video I have discovered a beautifully versatile motion technique via avy with evil mode. Both packages are admirable in their own right. avy brings char-based decision tree jumping to the buffer, and evil is an extensible vi layer for Emacs. Combining them, however, feels magic.
How it works Below is some elisp from my init file:
1 (global-set-key (kbd &amp;#34;C-x .&amp;#34;) (lambda () (interactive) (dired &amp;#34;~/.</description></item><item><title>Improving Vim Form</title><link>https://benmaclaurin.com/post/improving-vim-form/</link><pubDate>Thu, 20 Oct 2022 21:39:40 +0100</pubDate><guid>https://benmaclaurin.com/post/improving-vim-form/</guid><description>Introduction There is no wrong way to use Vim (unless of course you navigate via the inferior ←↑↓→) ;). Jokes aside, Vim is an incredibly versatile editor and users should traverse code by any means comfortable. However, after 2 years of usage I felt over-reliant on the hjkl and visual mode selection.
Avoiding repetition Assume we want to copy the following code block, a simple test:
1 2 3 4 5 #[test] fn convert_to_colemak() { assert_eq!</description></item><item><title>Tailscale, Obsidian and Syncthing</title><link>https://benmaclaurin.com/post/tailscale-obsidian-syncthing/</link><pubDate>Mon, 01 Aug 2022 20:58:33 +0100</pubDate><guid>https://benmaclaurin.com/post/tailscale-obsidian-syncthing/</guid><description>I&amp;rsquo;ll preface this by mentioning I&amp;rsquo;m no expert in any of the three tools referenced. Apologies in advance for any oversight.
Background Last month I setup a copy of TiddlyWiki (a self-hosted knowledge management tool) on a small Linode instance. TiddlyWiki comes with batteries included and a painless setup. With some further tweaks and the help of Tailscale (a simple VPN solution), I had an access anytime/anywhere personal and private knowledgebase.</description></item><item><title>Productivity with Hammerspoon</title><link>https://benmaclaurin.com/post/productivity-with-hammerspoon/</link><pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate><guid>https://benmaclaurin.com/post/productivity-with-hammerspoon/</guid><description>Hammerspoon is a tool for automating OS X tasks. In this post, I&amp;rsquo;ll share my configuration.
For window management, I&amp;rsquo;ve modelled the manipulation on Vim keybindings:
⌘ + Shift + H = width / 2 and left align ⌘ + Shift + J = height / 2 and bottom align ⌘ + Shift + K = height / 2 and top align ⌘ + Shift + L = width / 2 and right align The ⌘ + Shift + ↵ combination, which is less synonymous, maximises the target window.</description></item></channel></rss>