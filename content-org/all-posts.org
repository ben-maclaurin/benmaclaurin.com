#+startup: indent
#+startup: logdone
#+hugo_base_dir: ../
#+options: author:nil

* DONE Fast motions with avy and evil
CLOSED: [2022-10-30 Sun 00:49]
:PROPERTIES:
:EXPORT_HUGO_SECTION: post
:EXPORT_FILE_NAME: fast-motions-with-avy-and-evil 
:END:

I have discovered a beautifully versatile motion technique via avy with evil mode. Both packages are admirable in their own right. avy brings [[https://github.com/abo-abo/avy][char-based decision tree jumping]] to the buffer, and evil is [[https://github.com/emacs-evil/evil][an extensible vi layer]] for Emacs. Combining them, however, feels /magic/. 

** How it works
Below is some elisp from my init file:

#+begin_src lisp 
(global-set-key (kbd "C-x .") (lambda () (interactive) (dired "~/.emacs.d/")))
#+end_src

What if I want to delete from the beginning of the line to the end of ~(interactive)~? 

Maybe ~df)~? No. That would give me:

#+begin_src lisp 
 (lambda () (interactive) (dired "~/.emacs.d/")))
#+end_src

Instead, I could count the occurences of ~)~ up until the termination point (there are 3 in this case). ~d3f)~ would give me want I want:

#+begin_src lisp
 (dired "~/.emacs.d/")))
#+end_src

With avy, this becomes delightfully simple. We no longer need to count the occurences of a character. Instead, the following key combination will work:

1. ~d~ for delete
2. ~C-;~ which is my custom keybinding for ~avy-goto-char~
3. ~<char>~ where ~<char>~ is the target char
4. ~<avy char>~ which is the character in the visual decision tree which represents our target

Here is a screenshot of step 3:

[[file:avy-demo.png]]

In the example screenshot I would press ~d~ as this is the character that corresponds to the termination point.

So, in /approximately/ the same number of actions we achieved comparable behaviour without the additional cognitive load of having to count character occurences.

Before I switched to Emacs, I tried to set this up with [[https://github.com/ggandor/leap.nvim][leap]] in Neovim but couldn't get it to work properly.


* Rust: Trait Objects and the Newtype Pattern
** Introduction
I built a simple Hacker News wrapper in Rust to learn about API design principles. Along the way I also discovered the [[https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html][Newtype pattern]] which provides type safety and encapsulation. The following post is a summary of learnings:

I set a small challenge of building a wrapper around the Hacker News API. To keep the project simple and focus on the goal of studying idiomatic Rust, I only aggregated the top stories (i.e. frontpage matter) and ignored all other site categories (polls, jobs, etc.).

** Understanding the data structure
- Stories can have /many/ children
- Comments can have /many/ children
- Comments can have /only one/ parent

Both sotries and comments are "items". You may be able to spot a simple rule here:

- Stories are /always/ parents. Comments can be either parents /or/ children.

** Defining the item type
First, I defined the item type. 



* DONE Emacs configuration
CLOSED: [2022-10-29 Sat 18:07]
:PROPERTIES:
:EXPORT_HUGO_SECTION: post
:EXPORT_FILE_NAME: init-el-file
:END:

This page documents the contents of my init.el file and associated packages for [[https://www.gnu.org/software/emacs/][GNU Emacs]].

** Vanilla mods
This section documents the modifications I have made to the vanilla GNU Emacs distribution.

*** Archives
These lines initialise the package archives.

#+begin_src lisp
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")
                         ("elpa" . "https://elpa.gnu.org/packages/")))

(package-initialize)
(unless package-archive-contents
 (package-refresh-contents))

(unless (package-installed-p 'use-package)
   (package-install 'use-package))
#+end_src

*** Interface
The following lines make several modifications to the default Emacs interface. These are designed to make the display less cluttered with more room for the buffer.

#+begin_src lisp
(setq inhibit-startup-message t)
(scroll-bar-mode -1)
(tool-bar-mode -1)
(menu-bar-mode -1)
#+end_src

*** Typeface
This line sets the editor font size and face. I use [[https://gitlab.com/protesilaos/iosevka-comfy][Iosevka Comfy]] by Protesilaos Stavrou.

#+begin_src lisp
  (set-face-attribute 'default nil :font "Iosevka Comfy" :height 195)
#+end_src

*** Meta key

The following line remaps the Emacs meta ~M~ modifier to the slightly more erognomic macOS command key.

#+begin_src lisp
  (setq mac-command-modifier 'meta)
#+end_src

*** Quickly open Emacs config

This line opens the ~emacs.d~ directory with ~C-x .~

#+begin_src lisp
  (global-set-key (kbd "C-x .") (lambda () (interactive) (dired "~/.emacs.d/")))
#+end_src

*** Cursor type
Change the cursor type to bar, as I prefer it in non-modal editors.

#+begin_src lisp
  (setq-default cursor-type 'bar)
#+end_src

** Packages
External packages which I have installed and customised.

*** evil
Enable evil mode, which provides Vim keybinding support for Emacs:

#+begin_src lisp
(require 'evil)
(evil-mode 1)
#+end_src

This line maps ~C-u~ to ~PageUp~ in evil mode:

#+begin_src
(setq evil-want-C-u-scroll t)
#+end_src

Remap ~C-j~ and ~C-k~ to ~PageUp~ and ~PageDn~ respectively (via evil):

#+begin_src lisp
(global-set-key (kbd "C-j") (lambda () (interactive) (evil-scroll-down 0)))
(global-set-key (kbd "C-k") (lambda () (interactive) (evil-scroll-up 0)))
#+end_src

*** key-chord
I use the key-chord package to remap ~jk~ key presses in quick succession to escape:

#+begin_src lisp
(setq key-chord-two-keys-delay 0.3)
(key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
(key-chord-mode 1)
#+end_src

*** avy
avy allows you to jump around text. When a single char is entered, avy highlights candidates.

~C-;~ is bound to ~avy-goto-line~ to enable a shortcut for this functionality:

#+begin_src lisp
  (global-set-key (kbd "C-;") 'avy-goto-char)
#+end_src

A convenient key binding for line jumping in avy...

#+begin_src lisp
  (global-set-key (kbd "M-g f") 'avy-goto-line)
#+end_src

*** magit
The [[https://magit.vc/][magit]] package is an interface for Git inside Emacs. I use it for all Git-related operations.

I have bound ~C-x m~ to ~magit-status~ for quicker access to Magit:

#+begin_src lisp
(global-set-key (kbd "C-x m") 'magit-status)
#+end_src

*** eglot
[[https://github.com/joaotavora/eglot][eglot]] is an Emacs client for LSP (Language Server Protocol) servers. When ~M-x eglot~ is executed inside a file, Eglot attempts to find the associated LSP and run it.

*** tree-sitter-mode
Enables ~tree-sitter-mode~ globally. Treesitter is an incremental parsing library. 

#+begin_src lisp
  (global-tree-sitter-mode)
#+end_src

*** rust-mode
Instantiates a major mode for the [[https://www.rust-lang.org/][Rust programming language]]. 

#+begin_src lisp
  (require 'rust-mode)
#+end_src

*** ef-themes
I use the accessible ~ef-themes~ collection by [[https://protesilaos.com/][Protesilaos Stavrou]]. 

#+begin_src lisp
  (load-theme 'ef-summer)
#+end_src

*** ox-hugo
~ox-hugo~ provides a convenient way to export Org files to Hugo-compatible markdown. It is used in the generation of [[https://ben-maclaurin.github.io/][my personal blog]].

#+begin_src lisp
  (with-eval-after-load 'ox
  (require 'ox-hugo))
#+end_src
